<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>City Sort: Evacuaci√≥n Ordenada</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --ground-color: #334155;
            --road-color: #475569;
        }

        body {
            margin: 0;
            background: #0f172a;
            font-family: 'Outfit', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            color: white;
        }

        /* HUD */
        .hud-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2000;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            pointer-events: auto;
        }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            padding: 10px 20px;
            border-radius: 12px;
            color: white;
            text-decoration: none;
            font-weight: bold;
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .level-title {
            background: #ef4444;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 800;
            text-transform: uppercase;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
            font-size: 0.9rem;
        }

        /* MODALS */
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: #1e293b;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            max-width: 300px;
            width: 80%;
            z-index: 3000;
        }

        .modal.active {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }

        .action-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 15px 0;
            width: 100%;
            border-radius: 12px;
            font-weight: bold;
            font-size: 1.1rem;
            margin-top: 20px;
            cursor: pointer;
        }

        /* 3D WORLD CONTAINER */
        .scene {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            perspective: 1200px;
            /* Reduced perspective for more orthographic feel */
            overflow: hidden;
            background: linear-gradient(to bottom, #0f172a 0%, #1e293b 100%);
        }

        .world {
            position: relative;
            width: 600px;
            height: 600px;
            transform-style: preserve-3d;
            /* Improved Isometric Angle: X=54.7deg (approx 55), Z=45deg is true isometric */
            /* We use X=50deg for slightly better visibility of vertical faces */
            transform: rotateX(50deg) rotateZ(45deg);
            background: var(--ground-color);
            border-radius: 4px;
            box-shadow:
                -20px 20px 0 #0f172a,
                /* Fake terrain depth block */
                -40px 40px 80px rgba(0, 0, 0, 0.6);
            transition: transform 0.5s ease;
        }

        /* GRID / ROAD */
        .grid {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            transform: translateZ(0.1px);
            /* Avoid z-fighting with base */
        }

        .road-paint {
            position: absolute;
            background: var(--road-color);
            transform: translateZ(1px);
            border-radius: 2px;
        }

        .zone-label {
            position: absolute;
            transform: rotateZ(-45deg);
            color: rgba(255, 255, 255, 0.15);
            font-weight: 900;
            font-size: 2rem;
            pointer-events: none;
            white-space: nowrap;
            text-align: center;
        }

        /* 3D CUBE PRIMITIVES (Buildings) */
        .building {
            position: absolute;
            transform-style: preserve-3d;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Generic faces for solid buildings */
        .face {
            position: absolute;
            backface-visibility: hidden;
        }

        .face-top {
            width: var(--w);
            height: var(--d);
            background: var(--c-top);
            transform: translateZ(var(--h));
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .face-front {
            width: var(--w);
            height: var(--h);
            background: var(--c-front);
            transform: rotateX(-90deg) translateZ(calc(var(--d) / 2));
            bottom: 0;
            box-shadow: inset 0 -20px 30px rgba(0, 0, 0, 0.3);
            /* Ground shading */
        }

        .face-right {
            width: var(--d);
            height: var(--h);
            background: var(--c-side);
            transform: rotateY(90deg) translateZ(calc(var(--w) / 2));
            right: 0;
            bottom: 0;
            transform-origin: right bottom;
            box-shadow: inset -20px 0 30px rgba(0, 0, 0, 0.3);
        }

        /* Building States */
        .building.locked {
            filter: grayscale(1) brightness(0.5);
        }

        .building.complete .face-top {
            background: #10b981 !important;
            box-shadow: 0 0 20px #10b981;
            border-color: #4ade80;
        }

        /* Windows */
        .window-grid {
            display: flex;
            flex-wrap: wrap;
            padding: 6px;
            gap: 4px;
        }

        .win {
            width: 30%;
            height: 8px;
            background: #fbbf24;
            border-radius: 1px;
            box-shadow: 0 0 5px #fbbf24;
            opacity: 0.8;
        }

        /* Roof Icon */
        .roof-icon {
            font-size: 2rem;
            transform: rotateZ(-45deg);
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }

        /* PERSON (Char) - Improved proportions */
        .person {
            position: absolute;
            width: 20px;
            height: 20px;
            /* Footprint size */
            transform-style: preserve-3d;
            transition: all 0.3s cubic-bezier(0.2, 0.6, 0.2, 1);
            z-index: 100;
        }

        /* Body Cylinder/Box */
        .p-body {
            position: absolute;
            width: 14px;
            height: 14px;
            /* Width/Depth */
            /* Height is handled by scaling Y in transform */
            background: var(--c);
            top: 3px;
            left: 3px;
            /* Center in footprint */

            /* Constructing a simple box for body */
            transform: translateZ(10px);
            /* Lift half height */
            transform-style: preserve-3d;
        }

        /* We simulate a vertical prism using thick borders or multiple faces? 
           Let's use a single div rotated up. */
        .p-torso {
            position: absolute;
            width: 14px;
            height: 24px;
            /* Torso Height */
            background: var(--c);
            transform-origin: bottom center;
            transform: rotateX(-90deg) translateZ(-2px);
            /* Stand up */
            border-radius: 3px;
            box-shadow: inset 2px 0 5px rgba(0, 0, 0, 0.2);
        }

        /* Head */
        .p-head {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #f1f5f9;
            /* Skin/Helmet */
            border-radius: 4px;
            /* Position relative to footprint */
            transform: translateZ(26px) translateX(4px) translateY(4px);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        /* Shadow */
        .p-shadow {
            position: absolute;
            width: 100%;
            height: 100%;
            background: black;
            border-radius: 50%;
            filter: blur(3px);
            opacity: 0.4;
            transform: translateZ(0.1px);
        }

        /* DRAGGING STATE */
        .person.dragging {
            z-index: 1000;
            transition: none;
            cursor: grabbing;
        }

        .person.dragging .p-torso {
            transform: rotateX(-90deg) translateZ(-2px) scaleY(1.1);
            /* Stretch */
        }

        .person.dragging .p-head {
            transform: translateZ(35px) translateX(4px) translateY(4px);
            /* Lift head */
        }

        .person.dragging .p-shadow {
            transform: translateZ(0.1px) scale(0.5);
            /* Shrink shadow */
            opacity: 0.2;
        }

        /* WAITING SPOTS */
        .spot {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translateZ(1px);
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.2);
            font-weight: 800;
            font-size: 1.2rem;
        }
    </style>
</head>

<body>

    <div class="hud-layer">
        <div class="top-bar">
            <a href="index.html" class="btn">‚¨ÖÔ∏è Salir</a>
            <div style="text-align:center">
                <div class="level-title" id="lvl-txt">NIVEL 1</div>
                <div style="font-size:0.8rem; margin-top:5px; opacity:0.8" id="msg-txt">...</div>
            </div>
            <div class="btn">‚è≥ <span id="timer">60</span></div>
        </div>

        <div style="text-align:center; opacity:0.6; padding-bottom:20px;">
            <small>ARRASTRA AL PRIMERO DE LA FILA</small>
        </div>

        <!-- MODALS -->
        <div class="modal" id="modal-win">
            <h1 style="font-size:3rem; margin:0">üéâ</h1>
            <h2>¬°Excelente!</h2>
            <p>Zona evacuada correctamente.</p>
            <button class="action-btn" onclick="nextLevel()">Continuar ‚û°Ô∏è</button>
        </div>
        <div class="modal" id="modal-lose">
            <h1 style="font-size:3rem; margin:0">üöë</h1>
            <h2 style="color:#ef4444">¬°Bloqueo!</h2>
            <p id="fail-Reason">El orden se ha perdido.</p>
            <button class="action-btn" style="background:#ef4444" onclick="restartLevel()">Reintentar üîÑ</button>
        </div>
    </div>

    <div class="scene">
        <div class="world" id="world">
            <div class="grid"></div>
            <!-- Labels -->
            <div class="zone-label" style="left:50px; top:450px;">FILA</div>
            <div class="zone-label" style="left:400px; top:450px;">ESPERA</div>

            <!-- Dynamic Content -->
        </div>
    </div>

    <script>
        // CONFIGURATION
        const COLORS = {
            red: { top: '#ef4444', front: '#b91c1c', side: '#991b1b' },
            blue: { top: '#3b82f6', front: '#1d4ed8', side: '#1e40af' },
            green: { top: '#10b981', front: '#047857', side: '#065f46' },
            yellow: { top: '#facc15', front: '#b45309', side: '#92400e' },
            purple: { top: '#a855f7', front: '#7e22ce', side: '#6b21a8' }
        };

        const LEVELS = [
            {
                msg: "El Hospital Rojo tiene prioridad.",
                time: 45,
                buildings: [
                    { id: 'b_red', color: 'red', x: 250, y: 250, w: 100, d: 100, h: 80, cap: 2, icon: 'üè•', next: ['b_blue'] }, // Central
                    { id: 'b_blue', color: 'blue', x: 50, y: 50, w: 80, d: 80, h: 60, cap: 2, icon: 'üè¢', next: [] }  // Corner
                ],
                queue: ['blue', 'red', 'blue', 'red'],
                spots: 1
            },
            {
                msg: "Desbloquea el centro primero.",
                time: 60,
                buildings: [
                    // Center blocks corners
                    { id: 'b_green', color: 'green', x: 250, y: 250, w: 100, d: 100, h: 100, cap: 2, icon: '‚ö°', next: ['b_yellow', 'b_purple'] },
                    { id: 'b_yellow', color: 'yellow', x: 50, y: 350, w: 80, d: 80, h: 60, cap: 2, icon: 'üöï', next: [] },
                    { id: 'b_purple', color: 'purple', x: 350, y: 50, w: 80, d: 80, h: 80, icon: 'üè®', next: [] }
                ],
                queue: ['yellow', 'green', 'green', 'purple', 'yellow', 'purple'], // Mixed
                spots: 2 // Use spots to shuffle
            },
            {
                msg: "Secuencia Compleja",
                time: 90,
                buildings: [
                    { id: 'b_blue', color: 'blue', x: 400, y: 400, w: 100, d: 100, h: 120, cap: 3, icon: '1', next: ['b_red'] },
                    { id: 'b_red', color: 'red', x: 250, y: 250, w: 80, d: 80, h: 80, cap: 3, icon: '2', next: ['b_green'] },
                    { id: 'b_green', color: 'green', x: 100, y: 100, w: 60, d: 60, h: 60, cap: 3, icon: '3', next: [] }
                ],
                queue: ['green', 'green', 'red', 'red', 'blue', 'blue', 'green', 'red', 'blue'], // Reverse
                spots: 3
            }
        ];

        // GAME STATE
        let state = {
            lvl: 0,
            timer: 0,
            interval: null,
            buildings: [],
            queue: [], // {id, color}
            spots: [], // {id, color} or null
            maxSpots: 0,
            draggedEl: null,
            dragData: null // { startX, startY, initialLeft, initialTop }
        };

        const world = document.getElementById('world');

        // INIT
        function init() {
            const p = new URLSearchParams(location.search);
            state.lvl = (parseInt(p.get('level')) || 1) - 1;
            if (state.lvl >= LEVELS.length) state.lvl = 0;
            loadLevel(state.lvl);
        }

        function loadLevel(idx) {
            const data = LEVELS[idx];

            // Text
            document.getElementById('lvl-txt').innerText = `NIVEL ${idx + 1}`;
            document.getElementById('msg-txt').innerText = data.msg;
            document.getElementById('modal-win').classList.remove('active');
            document.getElementById('modal-lose').classList.remove('active');

            // Data Copy
            state.buildings = JSON.parse(JSON.stringify(data.buildings));
            state.buildings.forEach(b => b.filled = 0);

            state.queue = data.queue.map((c, i) => ({ id: `p_${i}`, color: c }));

            state.maxSpots = data.spots;
            state.spots = new Array(state.maxSpots).fill(null);

            state.timer = data.time;
            document.getElementById('timer').innerText = state.timer;

            renderStaticWorld(); // Terrain, buildings, spots
            updateLocks();       // Determine locked state
            renderEntities();    // People

            clearInterval(state.interval);
            state.interval = setInterval(() => {
                state.timer--;
                document.getElementById('timer').innerText = state.timer;
                if (state.timer <= 0) doLose("Tiempo agotado.");
            }, 1000);
        }

        function renderStaticWorld() {
            // Keep dynamic entites but clear static
            const dynamics = Array.from(document.querySelectorAll('.person'));
            world.innerHTML = '<div class="grid"></div>'; // Reset

            // Labels
            const l1 = document.createElement('div'); l1.className = 'zone-label'; l1.innerText = 'FILA'; l1.style.left = '50px'; l1.style.top = '480px'; world.appendChild(l1);
            const l2 = document.createElement('div'); l2.className = 'zone-label'; l2.innerText = 'ESPERA'; l2.style.left = '400px'; l2.style.top = '480px'; world.appendChild(l2);

            // Buildings
            state.buildings.forEach(b => {
                const el = document.createElement('div');
                el.className = 'building';
                el.id = b.id;
                const c = COLORS[b.color];

                // Position
                el.style.left = b.x + 'px'; el.style.top = b.y + 'px';
                el.style.setProperty('--w', b.w + 'px');
                el.style.setProperty('--d', b.d + 'px');
                el.style.setProperty('--h', b.h + 'px');
                el.style.setProperty('--c-top', c.top);
                el.style.setProperty('--c-front', c.front);
                el.style.setProperty('--c-side', c.side);

                el.innerHTML = `
                    <div class="face face-front"></div>
                    <div class="face face-right"></div>
                    <div class="face face-top">
                        <div class="roof-icon">${b.icon}</div>
                    </div>
                `;
                world.appendChild(el);
            });

            // Waiting Spots
            for (let i = 0; i < state.maxSpots; i++) {
                const s = document.createElement('div');
                s.className = 'spot';
                s.innerText = 'P' + (i + 1);
                s.style.left = (400 + (i * 60)) + 'px';
                s.style.top = '430px';
                s.dataset.idx = i;
                world.appendChild(s);
            }
        }

        function renderEntities() {
            // Clear old
            document.querySelectorAll('.person').forEach(e => e.remove());

            // Render Queue (First 6)
            state.queue.slice(0, 6).forEach((p, i) => {
                const isHead = (i === 0);
                // Stack vertically on screen left for the queue
                const tx = 50;
                const ty = 430 + (i * 35);

                const el = createPerson(p, tx, ty, isHead);
                if (!isHead) el.style.filter = "brightness(0.7)";
                world.appendChild(el);
            });

            // Render Spots
            state.spots.forEach((p, i) => {
                if (p) {
                    const tx = 400 + (i * 60) + 10;
                    const ty = 430 + 10;
                    const el = createPerson(p, tx, ty, true);
                    world.appendChild(el);
                }
            });
        }

        function createPerson(data, x, y, draggable) {
            const el = document.createElement('div');
            el.className = 'person';
            el.id = data.id;
            const c = COLORS[data.color].top;
            el.style.setProperty('--c', c);
            el.style.left = x + 'px';
            el.style.top = y + 'px';

            el.dataset.ox = x; el.dataset.oy = y;

            el.innerHTML = `
                <div class="p-shadow"></div>
                <div class="p-torso"></div>
                <div class="p-head"></div>
            `;

            if (draggable) setupDrag(el);
            return el;
        }

        // --- DRAG LOGIC ---
        function setupDrag(el) {
            el.addEventListener('mousedown', jsDragStart);
            el.addEventListener('touchstart', jsDragStart, { passive: false });
        }

        function jsDragStart(e) {
            if (state.draggedEl) return;
            e.preventDefault();

            const touch = e.touches ? e.touches[0] : e;
            state.draggedEl = e.currentTarget;

            state.dragData = {
                startX: touch.clientX,
                startY: touch.clientY,
                startLeft: parseFloat(state.draggedEl.style.left),
                startTop: parseFloat(state.draggedEl.style.top)
            };

            state.draggedEl.classList.add('dragging');

            document.addEventListener('mousemove', jsDragMove);
            document.addEventListener('touchmove', jsDragMove, { passive: false });
            document.addEventListener('mouseup', jsDragEnd);
            document.addEventListener('touchend', jsDragEnd);
        }

        function jsDragMove(e) {
            if (!state.draggedEl) return;
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;

            const dx = touch.clientX - state.dragData.startX;
            const dy = touch.clientY - state.dragData.startY;

            // REVISED ISOMETRIC MAPPING
            const rad = -45 * (Math.PI / 180);
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);

            let rDx = dx * cos - dy * sin;
            let rDy = dx * sin + dy * cos;

            // Compensate for Foreshortening (1 / cos(50deg))
            rDy = rDy * 1.55;

            state.draggedEl.style.left = (state.dragData.startLeft + rDx) + 'px';
            state.draggedEl.style.top = (state.dragData.startTop + rDy) + 'px';
        }

        function jsDragEnd(e) {
            if (!state.draggedEl) return;

            document.removeEventListener('mousemove', jsDragMove);
            document.removeEventListener('touchmove', jsDragMove);
            document.removeEventListener('mouseup', jsDragEnd);
            document.removeEventListener('touchend', jsDragEnd);

            const el = state.draggedEl;
            state.draggedEl = null;
            el.classList.remove('dragging');

            const rect = el.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;

            // 1. Check Buildings
            const buildings = document.querySelectorAll('.building');
            for (let b of buildings) {
                const bRect = b.getBoundingClientRect();
                if (cx >= bRect.left && cx <= bRect.right && cy >= bRect.top && cy <= bRect.bottom) {
                    handleBuildingDrop(el, b.id);
                    return;
                }
            }

            // 2. Check Spots
            const spots = document.querySelectorAll('.spot');
            for (let s of spots) {
                const sRect = s.getBoundingClientRect();
                if (cx >= sRect.left && cx <= sRect.right && cy >= sRect.top && cy <= sRect.bottom) {
                    handleSpotDrop(el, parseInt(s.dataset.idx));
                    return;
                }
            }

            // Reset
            el.style.left = el.dataset.ox + 'px';
            el.style.top = el.dataset.oy + 'px';
        }

        // --- GAME LOGIC ---
        function updateLocks() {
            const blockedIds = new Set();
            state.buildings.forEach(b => {
                if (b.filled < b.cap) {
                    b.next.forEach(targetId => blockedIds.add(targetId));
                }
            });

            state.buildings.forEach(b => {
                const el = document.getElementById(b.id);
                if (b.filled >= b.cap) {
                    el.classList.remove('locked');
                    el.classList.add('complete');
                } else if (blockedIds.has(b.id)) {
                    el.classList.add('locked');
                } else {
                    el.classList.remove('locked');
                }
            });
        }

        function handleBuildingDrop(el, bId) {
            const bData = state.buildings.find(b => b.id === bId);
            const pData = findPerson(el.id);
            const elB = document.getElementById(bId);

            if (elB.classList.contains('locked')) {
                doLose("¬°Edificio Bloqueado! Sigue el orden.");
                return;
            }
            if (bData.filled >= bData.cap) {
                resetEl(el);
                return;
            }
            if (bData.color !== pData.color) {
                resetEl(el);
                return; // Forgiveness, no lose
            }

            // Success
            removePersonFromSource(el.id);
            bData.filled++;
            updateLocks();

            el.remove();
            renderEntities();

            checkWin();
        }

        function handleSpotDrop(el, idx) {
            if (state.spots[idx] !== null) {
                resetEl(el); // Spot full
                return;
            }

            const pData = findPerson(el.id);
            removePersonFromSource(el.id);
            state.spots[idx] = pData;

            el.remove();
            renderEntities();

            checkWin(); // Check for deadlock after move
        }

        function findPerson(id) {
            if (state.queue[0] && state.queue[0].id === id) return state.queue[0];
            return state.spots.find(s => s && s.id === id);
        }

        function removePersonFromSource(id) {
            if (state.queue[0] && state.queue[0].id === id) {
                state.queue.shift();
            } else {
                const idx = state.spots.findIndex(s => s && s.id === id);
                if (idx !== -1) state.spots[idx] = null;
            }
        }

        function resetEl(el) {
            el.style.left = el.dataset.ox + 'px';
            el.style.top = el.dataset.oy + 'px';
        }

        function checkWin() {
            const totalCap = state.buildings.reduce((a, b) => a + b.cap, 0);
            const totalFill = state.buildings.reduce((a, b) => a + b.filled, 0);

            if (totalFill >= totalCap) {
                clearInterval(state.interval);
                document.getElementById('modal-win').classList.add('active');
                return;
            }

            // Check Deadlock
            const head = state.queue[0];
            const spotPeople = state.spots.filter(s => s !== null);

            // Open = Not Filled AND Not Locked
            // We can check locked class or logic. Logic is safer.
            // But we need the blockedIds logic again? Or trust class. 
            // Let's trust class for simplicity as it syncs with updateLocks.
            const openBuildings = Array.from(document.querySelectorAll('.building'))
                .filter(el => !el.classList.contains('locked') && !el.classList.contains('complete'))
                .map(el => state.buildings.find(b => b.id === el.id));

            let possible = false;

            // Can Head Move?
            if (head) {
                // To Building
                if (openBuildings.some(b => b.color === head.color)) possible = true;
                // To Spot (if empty spot exists)
                if (state.spots.some(s => s === null)) possible = true;
            }

            // Can Spot People Move?
            spotPeople.forEach(p => {
                if (openBuildings.some(b => b.color === p.color)) possible = true;
            });

            // If no possible moves, and we still have people to place...
            if (!possible) {
                doLose("¬°Bloqueo Total! No quedan movimientos.");
            }
        }

        function doLose(reason) {
            clearInterval(state.interval);
            document.getElementById('fail-Reason').innerText = reason;
            document.getElementById('modal-lose').classList.add('active');
        }

        function nextLevel() {
            window.location.href = `city_sort.html?level=${state.lvl + 2}`;
        }
        function restartLevel() {
            location.reload();
        }

        init();

    </script>
</body>

</html>